#!/usr/bin/env bash

# Shiv Build Script (Bash)
# Builds the pipeline.pyz executable using shiv.
# This script is designed to be run in a Unix-like environment (WSL, Linux, Termux)
# to ensure the resulting .pyz file has correct LF line endings for Linux/Unix execution.

# New function to get project name from pyproject.toml
get_project_name_from_toml() {
    local TOML_FILE="pyproject.toml"
    if [ ! -f "$TOML_FILE" ]; then
        echo "pipeline" # Default fallback if file is missing
        return 0
    fi

    # Tries to extract name from [project] (PEP 621) or [tool.poetry] sections
    # Filters for 'name = ...', extracts the value, and removes quotes/spaces.
    NAME=$(grep -A 5 -E '\[(project|tool\.poetry)\]' "$TOML_FILE" | grep -E '^\s*name\s*=' | head -n 1 | cut -d '=' -f 2 | tr -d ' "[:space:]' | tr -d "'")

    if [ -z "$NAME" ]; then
        echo "pipeline" # Default fallback if name not found
    else
        echo "$NAME"
    fi
}

# 1. Determine Project Names from TOML
PROJECT_NAME_RAW=$(get_project_name_from_toml)
# Use project name with underscores for the module import (entry point), required by Python imports
PROJECT_MODULE_NAME=$(echo "$PROJECT_NAME_RAW" | tr '-' '_')


# --- Configuration ---
# PROJECT_NAME is used for file paths (retains hyphens if present)
PROJECT_NAME="$PROJECT_NAME_RAW"
OUTPUT_DIR="dist"
OUTPUT_FILE="${OUTPUT_DIR}/${PROJECT_NAME}.pyz"
# ENTRY_POINT uses the underscored module name for Python imports
ENTRY_POINT="${PROJECT_MODULE_NAME}.cli:app"


# Find the Python executable
PYTHON_BIN=$(command -v python3 || command -v python)
if [ -z "$PYTHON_BIN" ]; then
    echo "Error: Python 3 not found. Please ensure 'python3' or 'python' is in your PATH."
    exit 1
fi

# Function to generate a reliable Windows Batch file launcher
generate_windows_launcher() {
    # The launcher file path
    LAUNCHER_FILE="${OUTPUT_DIR}/${PROJECT_NAME}.bat"

    # Create the Batch script content
    cat > "$LAUNCHER_FILE" << EOF
@echo off
rem Generated by build_shiv.sh on a Unix system (using LF line endings).
rem This script ensures the console stays open after execution and handles pathing reliably.

setlocal
set PYTHON_EXE=python.exe
set PYZ_FILE=${PROJECT_NAME}.pyz

echo Running %PYZ_FILE%...

rem 1. Change to the directory of the batch file (%~dp0) to ensure the PYZ file is found.
rem PUSHD also handles UNC network paths by temporarily mapping them to a drive letter.
PUSHD "%~dp0"

rem 2. Execute the PYZ file using python.exe, passing all command-line arguments (%*).
rem We use a simple relative path because PUSHD guarantees the CWD is 'dist/'.
"%PYTHON_EXE%" "%PYZ_FILE%" %*

rem 3. Return to the original directory.
POPD

rem 4. Wait for user input to prevent the console window from immediately closing.
PAUSE

endlocal
EOF

    echo "Generated Windows launcher: ${LAUNCHER_FILE}"
}

# --- Main Build Process ---

# 1. Ensure shiv is installed via pipx (isolated installation)
echo "Ensuring shiv is installed via pipx..."
"$PYTHON_BIN" -m pip install --upgrade pipx
"$PYTHON_BIN" -m pipx install shiv --force || { echo "Error: Failed to install shiv via pipx."; exit 1; }

# 2. Setup output directory
mkdir -p "$OUTPUT_DIR"
echo "Output directory created: ${OUTPUT_DIR}"

# 3. Attempt to build the shiv file from a local wheel (Path A: Fastest and most stable)
# We explicitly add 'backports.zoneinfo' here to ensure the dependency is included,
# even if the project's dependency definition is conditional or incomplete for the build target.
echo "Attempting to build from source using 'pip install . backports.zoneinfo' and then shiv..."
if "$PYTHON_BIN" -m pip install . backports.zoneinfo --target="temp_build_target" --no-deps --no-cache-dir; then
    echo "Local package built successfully to temp_build_target."
    
    # Run shiv command using the locally installed package
    if shiv -o "$OUTPUT_FILE" -c "$ENTRY_POINT" --no-deps --site-packages "temp_build_target" . ; then
        echo "Success: Executable built using local installation and site-packages."
        generate_windows_launcher
    else
        echo "Error: shiv failed using Path A (site-packages). Falling back to Path B."
        # Cleanup temporary directory
        rm -rf temp_build_target
        # Fall through to Path B
    fi
    # Cleanup temporary directory
    rm -rf temp_build_target
else
    echo "Error: Local package installation failed (Path A). Falling back to Path B."
fi


# 4. Fallback: Build directly from source dependencies (Path B: Simpler, relies on pyproject.toml)
# This path is executed only if Path A failed or was skipped.
if [ ! -f "$OUTPUT_FILE" ] || [ ! -s "$OUTPUT_FILE" ]; then
    echo "Attempting to build directly from dependencies (Path B)..."
    echo "NOTE: This requires a pyproject.toml or setup.py file in the current directory ('.') to correctly install the 'pipeline' package."
    
    # We use shiv . to install the package defined in the current directory (requires pyproject.toml)
    if shiv . -o "$OUTPUT_FILE" -c "$ENTRY_POINT" -e ; then
        echo "Success: Executable built directly from dependencies."
        generate_windows_launcher
    else
        echo "Fatal Error: shiv failed using both build paths. Check your pyproject.toml dependencies."
        exit 1
    fi
fi

echo "Build complete. Executable available at: ${OUTPUT_FILE}"
